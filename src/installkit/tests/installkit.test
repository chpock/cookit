# installkit tests - installkit package
#
# Copyright (C) 2024 Konstantin Kushnir <chpock@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

if { [lsearch [namespace children] ::tcltest] == -1 } {
    package require tcltest 2
    namespace import -force ::tcltest::*
}

source [file join [tcltest::testsDirectory] helper.tcl]

package require installkit

# ::installkit::recursive_glob

test ik-1.1 {A file as input} -setup {
    set file [makeFile {} file]
} -body {
    ::installkit::recursive_glob $file *
} -result {} -cleanup {
    file delete -force $file
}

test ik-1.2 {An empty directory as input} -setup {
    set dir [makeDirectory dir]
} -body {
    ::installkit::recursive_glob $dir *
} -result {} -cleanup {
    file delete -force $dir
}

test ik-1.3 {Non-existing directory as input} -setup {} -body {
    ::installkit::recursive_glob wrong-dir *
} -result {} -cleanup {}

test ik-1.4 {An directory with one file as input} -setup {
    set dir [makeDirectory dir]
    makeFile {} [file join $dir file]
} -body {
    llength [::installkit::recursive_glob $dir *]
} -result 1 -cleanup {
    file delete -force $dir
}

test ik-1.5 {An directory with 3 files as input} -setup {
    set dir [makeDirectory dir]
    makeFile {} [file join $dir file1]
    makeFile {} [file join $dir file2.foo]
    makeFile {} [file join $dir file3]
} -body {
    list \
        [llength [::installkit::recursive_glob $dir *]] \
        [llength [::installkit::recursive_glob $dir *.foo]]
} -result {3 1} -cleanup {
    file delete -force $dir
}

test ik-1.6 {An directory tree as input} -setup {
    set dir [makeDirectory dir]
    makeFile {} [file join $dir file1]
    makeFile {} [file join $dir file2.foo]
    makeFile {} [file join $dir file3]
    set subdir [makeDirectory subdir $dir]
    makeFile {} [file join $subdir file2.foo]
    makeFile {} [file join $subdir file3]
} -body {
    list \
        [llength [::installkit::recursive_glob $dir *]] \
        [llength [::installkit::recursive_glob $dir *.foo]]
} -result {5 2} -cleanup {
    file delete -force $dir
}

# ::installkit::tmpmount

test ik-2.1 {::installkit::tmpmount} -body {
    ::installkit::tmpmount
} -result {/installkittmpvfs1}

test ik-2.2 {::installkit::tmpmount, the first mount point is busy} -setup {
    # cleanup the mount counter
    unset ::installkit::tmpMountCount
    # make busy mount point
    set vfs [tcltest::makeFile {} vfs]
    set tmpmount [::installkit::tmpmount]
    ::cookfs::Mount $vfs $tmpmount
    # cleanup the mount counter
    unset ::installkit::tmpMountCount
} -body {
    ::installkit::tmpmount
} -result {/installkittmpvfs2} -cleanup {
    ::cookfs::Unmount $tmpmount
    file delete -force $vfs
}

test ik-2.3 {::installkit::tmpmount, twice} -setup {
    # cleanup the mount counter
    unset ::installkit::tmpMountCount
} -body {
    list [::installkit::tmpmount] [::installkit::tmpmount]
} -result {/installkittmpvfs1 /installkittmpvfs2}

test ik-2.4 {::installkit::tmpmount, call the third time without cleanup} -body {
    ::installkit::tmpmount
} -result {/installkittmpvfs3}

# ::installkit::addfiles

test ik-3.1 {::installkit::addfiles} -setup {
    set vfs [tcltest::makeFile {} vfs]
    set dir [makeDirectory dir]
    set f1 [makeFile {cf1} [file join $dir file1]]
    set f2 [makeFile {cf2} [file join $dir file2.foo]]
    set f3 [makeFile {cf3} [file join $dir file3]]
    set subdir [makeDirectory subdir $dir]
    set f1a [makeFile {cf1a} [file join $subdir file2.foo]]
    set f2a [makeFile {cf2a} [file join $subdir file3]]
} -body {
    ::installkit::addfiles $vfs \
        [list $f1 $f2  $f3  $f1a $f2a] \
        [list f1  s/f2 x/f3 foo  bar ]
    ::cookfs::Mount $vfs $vfs
    join [concat \
        [lsort [::installkit::recursive_glob $vfs *]] \
        [list [getfile [file join $vfs s/f2]] [getfile [file join $vfs bar]]]] \n
} -match glob -result {*/bar
*/f1
*/foo
*/s/f2
*/x/f3
cf2

cf2a
} -cleanup {
    ::cookfs::Unmount $vfs
    file delete -force $vfs $dir
}

proc checkWrapArgs { args } {
    set def [dict create {*}{
        catalogs    {}
        command     {}
        executable  {}
        icon        {}
        level       6
        mainScript  {}
        method      zlib
        packages    {}
        password    {}
        stubfile    {}
        versionInfo {
            CompanyName      {}
            LegalCopyright   {}
            FileVersion      {}
            ProductName      {}
            ProductVersion   {}
            FileDescription  {}
            OriginalFilename {}
        }
        wrapFiles   {}
        wrapMethods {}
        wrapNames   {}
    }]
    foreach { k v } $args { dict set def {*}$k $v }
    dict set def versionInfo [lsort -stride 2 [dict get $def versionInfo]]
    return [lsort -stride 2 $def]
}

proc sortWrapArgs { vals } {
    dict set vals versionInfo [lsort -stride 2 [dict get $vals versionInfo]]
    return [lsort -stride 2 $vals]
}

# ::installkit::parseWrapArgs

test ik-4.1 {::installkit::parseWrapArgs, default arguments} -body {
    sortWrapArgs [::installkit::parseWrapArgs ""]
} -result [checkWrapArgs]

test ik-4.2.1.1 {::installkit::parseWrapArgs -f} -setup {
    set file [tcltest::makeFile [string trim {
f1 n1 zlib
f2 n2 m1
}] list]
} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -f $file]]
} -result [checkWrapArgs \
    wrapFiles {f1 f2} \
    wrapMethods {zlib m1} \
    wrapNames {n1 n2} \
] -cleanup {
    file delete -force $file
}

test ik-4.2.1.1 {::installkit::parseWrapArgs -f, not existing file} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -f wrong-file]]
} -returnCodes error -match glob -result "Could not find list file: wrong-file*"

test ik-4.2.1.2 {::installkit::parseWrapArgs -f} -setup {
    set file [makeFile {f1 n1 zlib
f2 n2 none} file1]
} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -f $file]]
} -result [checkWrapArgs wrapFiles {f1 f2} wrapMethods {zlib none} wrapNames {n1 n2}] -cleanup {
    file delete -force $file
}

test ik-4.2.2 {::installkit::parseWrapArgs -o} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -o f/o\\o]]
} -result [checkWrapArgs executable f/o/o]

test ik-4.2.3 {::installkit::parseWrapArgs -w} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -w f\\o/o]]
} -result [checkWrapArgs stubfile f/o/o]

# unsupported
test ik-4.2.4 {::installkit::parseWrapArgs -method} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -method foo]]
} -result [checkWrapArgs]

test ik-4.2.5 {::installkit::parseWrapArgs -level} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -level 99]]
} -result [checkWrapArgs level 99]

test ik-4.2.6 {::installkit::parseWrapArgs -command} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -command foo]]
} -result [checkWrapArgs command foo]

test ik-4.2.7 {::installkit::parseWrapArgs -password} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -password foo]]
} -result [checkWrapArgs password foo]

test ik-4.2.8 {::installkit::parseWrapArgs -icon} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -icon foo]]
} -result [checkWrapArgs icon foo]

test ik-4.2.9 {::installkit::parseWrapArgs -company} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -company foo]]
} -result [checkWrapArgs {versionInfo CompanyName} foo]

test ik-4.2.10 {::installkit::parseWrapArgs -copyright} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -copyright foo]]
} -result [checkWrapArgs {versionInfo LegalCopyright} foo]

test ik-4.2.11 {::installkit::parseWrapArgs -fileversion} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -fileversion foo]]
} -result [checkWrapArgs {versionInfo FileVersion} foo]

test ik-4.2.12 {::installkit::parseWrapArgs -productname} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -productname foo]]
} -result [checkWrapArgs {versionInfo ProductName} foo]

test ik-4.2.13 {::installkit::parseWrapArgs -productversion} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -productversion foo]]
} -result [checkWrapArgs {versionInfo ProductVersion} foo]

test ik-4.2.14 {::installkit::parseWrapArgs -filedescription} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -filedescription foo]]
} -result [checkWrapArgs {versionInfo FileDescription} foo]

test ik-4.2.15 {::installkit::parseWrapArgs -originalfilename} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -originalfilename foo]]
} -result [checkWrapArgs {versionInfo OriginalFilename} foo]

test ik-4.2.16 {::installkit::parseWrapArgs -catalog} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -catalog foo -catalog bar -catalog baz -catalog bar -catalog qux]]
} -result [checkWrapArgs catalogs {foo bar baz qux}]

test ik-4.2.17 {::installkit::parseWrapArgs -package} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -package foo -package bar -package baz -package bar -package qux]]
} -result [checkWrapArgs packages {foo bar baz qux}]

test ik-4.3.1 {::installkit::parseWrapArgs, unknown parameter -> main script} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list foo]]
} -result [checkWrapArgs mainScript foo]

test ik-4.3.2 {::installkit::parseWrapArgs, unknown parameter, unknown file} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -w foo bla -f]]
} -returnCodes error -result "Not a directory or a readable file: -f"

test ik-4.3.3 {::installkit::parseWrapArgs, end of parameters} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -w foo -- -f]]
} -result [checkWrapArgs stubfile foo mainScript -f]

test ik-4.3.4 {::installkit::parseWrapArgs, files} -setup {
    set f1 [makeFile {} file1]
    set f2 [makeFile {} file2]
} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -w foo -- main $f1 $f2]]
} -match glob -result [checkWrapArgs stubfile foo mainScript main \
    wrapFiles {*/file1 */file2} \
] -cleanup {
    file delete -force $f1 $f2
}

test ik-4.3.4 {::installkit::parseWrapArgs, files} -setup {
    set f1 [makeFile {} file1]
    set f2 [makeFile {} file2]
    set dir [makeDirectory dir]
    makeFile {} [file join $dir file1]
    makeFile {} [file join $dir file2.foo]
    makeFile {} [file join $dir file3]
    set subdir [makeDirectory subdir $dir]
    makeFile {} [file join $subdir file2.foo]
    makeFile {} [file join $subdir file3]
} -body {
    sortWrapArgs [::installkit::parseWrapArgs [list -w foo main $f1 $dir $f2]]
} -match glob -result [checkWrapArgs stubfile foo mainScript main \
    wrapFiles {*/file1 */dir/file1 */dir/file2.foo */dir/file3 */dir/subdir/file2.foo */dir/subdir/file3 */file2} \
] -cleanup {
    file delete -force $f1 $f2 $dir
}

# ::installkit::ParsePEResources

test ik-4.4.1 {::installkit::parsePEResources} -constraints win -setup {
    set exe [makeFile {} temp.exe]
    file copy -force [interpreter] $exe
} -body {
    set resources [::installkit::parsePEResources $exe]
    set result [list]
    foreach resource [lsort [dict keys $resources]] {
        lappend result ">$resource"
        if { $resource eq "icon" } {
            lappend result {*}[lsort [dict keys [dict get $resources $resource]]]
        } elseif { $resource eq "version" } {
            foreach vres [lsort [dict keys [dict get $resources $resource]]] {
                set vdata [dict get $resources $resource $vres]
                switch -- $vres {
                    dwFileVersionMS -
                    dwFileVersionLS -
                    dwProductVersionMS -
                    dwProductVersionLS -
                    dwFileDateMS -
                    dwFileDateLS {
                        lappend result "$vres [dict get $vdata value]"
                    }
                    default {
                        lappend result "$vres [dict get $vdata length]"
                    }
                }
            }
        }
    }
    join $result \n
} -result {>icon
16x32@4
16x32@8
32x64@4
32x64@8
48x96@4
48x96@8
>version
CompanyName 65
FileDescription 129
FileVersion 33
LegalCopyright 65
OriginalFilename 65
ProductName 65
ProductVersion 33
dwFileDateLS 0
dwFileDateMS 0
dwFileVersionLS 0
dwFileVersionMS 0
dwProductVersionLS 0
dwProductVersionMS 0} -cleanup {
    file delete -force $exe
}

# ::installkit::makestub

proc recursiveCompare { a b { strict 0 } } {

    if { $strict } {
        if { ![file exists $a] } { return "Not OK: $a doesn't exist" }
        if { ![file exists $b] } { return "Not OK: $b doesn't exists" }

        #if { [file mtime $a] != [file mtime $b] } {
        #    return "Not OK: file mtime $a != file mtime $b ([file mtime $a] != [file mtime $b])"
        #}

        if { [file type $a] ne [file type $b] } {
            return "Not OK: file type $a ne file type b ([file type $a] ne [file type b])"
        }
    }

    if { [file type $a] eq "file" } {
        if { [getfile $a] ne [getfile $b] } {
            return "Not OK: file content $a ne file content $b"
        }
    } elseif { [file type $a] eq "directory" } {
        set c [concat [glob -nocomplain -directory $a -tails *] [glob -nocomplain -directory $b -tails *]]
        set c [lsort -unique $c]
        foreach f $c {
            set res [recursiveCompare [file join $a $f] [file join $b $f] 1]
            if { $res ne "OK" } {
                return $res
            }
        }
    }

    return OK

}

test ik-4.5.1 {::installkit::makestub, can create and run a new kit} -setup {
    set exe [makeFile {} temp.exe]
    set script [makeFile {puts OK} script]
} -body {

    ::installkit::makestub $exe

    set result [list [exec $exe $script]]

    set mnt [::installkit::tmpmount]
    cookfs::Mount $exe $mnt
    lappend result [recursiveCompare $::installkit::root $mnt]
    cookfs::Unmount $mnt

    return $result

} -result {OK OK} -cleanup {
    catch { cookfs::Unmount $mnt }
    file delete -force $exe $script
}

test ik-4.5.2 {::installkit::makestub, no custom files in a new kit} -setup {
    set exe1 [makeFile {} temp1.exe]
    set exe2 [makeFile {} temp2.exe]
    set script1 [makeFile [subst -nobackslashes -nocommands {
        package require installkit
        ::installkit::makestub {$exe2}
    }] script1]
    set script2 [makeFile {puts OK} script2]
} -body {
    ::installkit::makestub $exe1
    set mnt [::installkit::tmpmount]
    ::cookfs::Mount $exe1 $mnt
    # create some files/directories
    close [open [file join $mnt bar] w]
    file mkdir [file join $mnt foo]
    close [open [file join $mnt foo baz] w]
    ::cookfs::Unmount $mnt
    # create $exe2 from $exe1
    exec [interpreter] $script1
    # check $exe2
    ::cookfs::Mount $exe2 $mnt
    set result [recursiveCompare $::installkit::root $mnt]
    ::cookfs::Unmount $mnt
    return $result
} -result {OK} -cleanup {
    catch { ::cookfs::Unmount $mnt }
    file delete -force $exe1 $exe2 $script1 $script2
}

test ik-4.6.1 {::installkit::parseIcoFile} -setup { } -body {
    lsort [dict keys [::installkit::parseIcoFile [file join [testsDirectory] misc music.ico]]]
} -result {16x32@32 16x32@4 16x32@8 32x64@32 32x64@4 32x64@8 48x96@32 48x96@4 48x96@8}

# ::installkit::updateWindowsResources
# These tests run only on Windows because we use twapi to check the results.

test ik-4.7.1 {::installkit::updateWindowsResources, versionInfo} -constraints win -setup {
    package require twapi
    set exe [makeFile {} temp.exe]
    file copy -force [interpreter] $exe
} -body {
    set result [list]
    foreach { param twapiParam val } {
        -company          CompanyName      fakecomp
        -copyright        LegalCopyright   "(c) foo"
        -fileversion      FileVersion      1.7.0.12
        -productname      ProductName      bar
        -productversion   ProductVersion   1.23
        -filedescription  FileDescription  "some long description"
        -originalfilename OriginalFilename file-file-file.exe
    } {
        ::installkit::updateWindowsResources [::installkit::parseWrapArgs \
            [list -o $exe $param $val]]
        set actual [dict get [::twapi::get_file_version_resource $exe $twapiParam] $twapiParam]
        if { $actual eq $val } continue
        lappend result "failed '$param'. Expected: '$val'; Actual: '$actual'"
    }
    join $result \n
} -result {} -cleanup {
    file delete -force $exe
}

test ik-4.7.2 {::installkit::updateWindowsResources, versionInfo with empty values} -constraints win -setup {
    package require twapi
    set exe [makeFile {} temp.exe]
    file copy -force [interpreter] $exe
} -body {
    ::installkit::updateWindowsResources [::installkit::parseWrapArgs [list -o $exe]]
    lsort -stride 2 [::twapi::get_file_version_resource $exe -all]
} -match glob -result {-datetime 0 -fileos windows32 -filetype application -fileversion 0.0.0.0 -flags {} -foundcodepage 0x04b0 -foundlangid {0x0409 {*}} -productversion 0.0.0.0 -signature 0xfeef04bd -structversion 1.0} -cleanup {
    file delete -force $exe
}

test ik-4.7.3.1 {::installkit::updateWindowsResources, fixed versions} -constraints win -setup {
    package require twapi
    set exe [makeFile {} temp.exe]
    file copy -force [interpreter] $exe
} -body {
    ::installkit::updateWindowsResources [::installkit::parseWrapArgs [list \
        -o $exe -fileversion 1.2.3.4.5 -productversion 6.7.8.9]]
    lsort -stride 2 [::twapi::get_file_version_resource $exe -fileversion -productversion FileVersion ProductVersion]
} -result {-fileversion 1.2.3.4 -productversion 6.7.8.9 FileVersion 1.2.3.4.5 ProductVersion 6.7.8.9} -cleanup {
    file delete -force $exe
}

test ik-4.7.3.2 {::installkit::updateWindowsResources, fixed versions with wrong strings} -constraints win -setup {
    package require twapi
    set exe [makeFile {} temp.exe]
    file copy -force [interpreter] $exe
} -body {
    # not a number
    # empty
    # negative integer
    # number 0xffff
    # number greater than 0xffff
    # not 4 digits
    ::installkit::updateWindowsResources [::installkit::parseWrapArgs [list \
        -o $exe -fileversion foo..-3.65535 -productversion 65536]]
    lsort -stride 2 [::twapi::get_file_version_resource $exe -fileversion -productversion FileVersion ProductVersion]
} -result {-fileversion 0.0.0.65535 -productversion 0.0.0.0 FileVersion foo..-3.65535 ProductVersion 65536} -cleanup {
    file delete -force $exe
}

test ik-4.7.4.1 {::installkit::updateWindowsResources, replace icon} -constraints win -setup {
    package require twapi
    set exe [makeFile {} temp.exe]
    file copy -force [interpreter] $exe
    set ico [file join [testsDirectory] misc music.ico]
} -body {
    set result [list]
    set ico_from_file [::installkit::parseIcoFile $ico]
    lappend result "Num icons in file: [dict size $ico_from_file]"
    ::installkit::updateWindowsResources [::installkit::parseWrapArgs [list \
        -o $exe -icon $ico]]
    # load icon data from test file by twapi
    set h [::twapi::load_library $exe -datafile]
    set ico_from_twapi [list]
    # 3 - RT_ICON
    foreach id [::twapi::enumerate_resource_names $h 3] {
        lappend ico_from_twapi [::twapi::read_resource $h 3 $id 0]
    }
    ::twapi::free_library $h
    lappend result "Num icons in exe: [llength $ico_from_twapi]"
    for { set i 0 } { $i < [llength $ico_from_twapi] } { incr i } {
        set data [lindex $ico_from_twapi $i]
        unset -nocomplain found
        dict for { k v } $ico_from_file {
            if { $data ne [dict get $v data] } continue
            set found $k
            break
        }
        if { ![info exists found] } {
            lappend result "Icon#$i was not found"
            continue
        }
        lappend result "Icon#$i was found as $found"
        dict unset ico_from_file $k
    }
    lappend result "Icons in file, but not in exe: [lsort [dict keys $ico_from_file]]"
    join $result \n
} -result {Num icons in file: 9
Num icons in exe: 6
Icon#0 was found as 16x32@4
Icon#1 was found as 16x32@8
Icon#2 was found as 32x64@4
Icon#3 was found as 32x64@8
Icon#4 was found as 48x96@4
Icon#5 was found as 48x96@8
Icons in file, but not in exe: 16x32@32 32x64@32 48x96@32} -cleanup {
    file delete -force $exe
}

test ik-4.7.4.2 {::installkit::updateWindowsResources, replace icon, non-existing file} -constraints win -setup {
    package require twapi
    set exe [makeFile {} temp.exe]
    file copy -force [interpreter] $exe
} -body {
    ::installkit::updateWindowsResources [::installkit::parseWrapArgs [list \
        -o $exe -icon nofile]]
} -returnCodes error -result "the icon file does not exist or not readable: nofile" -cleanup {
    file delete -force $exe
}

# ::installkit::wrap

set exeext [expr { $::tcl_platform(platform) eq "windows" ? {.exe} : {} }]

test ik-4.8.1 {::installkit::wrap, bad main script} -body {
    ::installkit::wrap wrong-file
} -returnCodes error -result {could not find the main script 'wrong-file' to wrap}

test ik-4.8.2 {::installkit::wrap, unknown output} -body {
    ::installkit::wrap
} -returnCodes error -result {no output file specified}

test ik-4.8.3 {::installkit::wrap, default kit name from script} -setup {
    set script [makeFile {puts OK} temp-ik-4.8.3.tcl]
} -body {
    ::installkit::wrap $script
    exec [set exe "[file rootname $script]$exeext"]
} -result {OK} -cleanup {
    file delete -force $script $exe
}

test ik-4.8.4 {::installkit::wrap, custom stub file, output name} -setup {
    set exe1 [makeFile {} src-ik-4.8.3.exe]
    file copy -force [interpreter] $exe1
    set script [makeFile {puts OK} temp-ik-4.8.4.tcl]
    set exe2 [makeFile {} dst-ik-4.8.3.exe]
} -body {
    ::installkit::wrap -w $exe1 -o $exe2 $script
    exec $exe2
} -result {OK} -cleanup {
    file delete -force $exe1 $exe2 $script
}

test ik-4.8.5 {::installkit::wrap, update windows resources} -constraints win -setup {
    set exe [makeFile {} temp.exe]
    set script [makeFile {puts OK} temp-ik-4.8.5.tcl]
} -body {
    ::installkit::wrap -o $exe -productname foo -copyright bar
    set result [exec $exe $script]
    append result " " [lsort -stride 2 [::twapi::get_file_version_resource $exe ProductName LegalCopyright]]
} -result {OK LegalCopyright bar ProductName foo} -cleanup {
    file delete -force $exe $script
}

test ik-4.8.6 {::installkit::wrap, add packages} -setup {
    set dir1 [makeDirectory foo1.0]
    makeFile {package ifneeded foo 1.0 { package provide foo 1.0; puts fooOK }} \
        [file join $dir1 pkgIndex.tcl]
    set dir2 [makeDirectory bar1.0]
    makeFile {package ifneeded bar 1.0 { package provide bar 1.0; puts barOK }} \
        [file join $dir2 pkgIndex.tcl]
    set exe [makeFile {} temp.exe]
    set script [makeFile {package require foo; package require bar} temp.tcl]
} -body {
    ::installkit::wrap -package $dir1 -o $exe -package $dir2 $script
    exec $exe
} -result {fooOK
barOK} -cleanup {
    file delete -force $dir1 $dir2 $exe $script
}

test ik-4.8.7 {::installkit::wrap, add catalogs} -setup {
    set dir1 [makeDirectory foo]
    makeFile {fooOK} [file join $dir1 test]
    set dir2 [makeDirectory bar]
    makeFile {barOK} [file join $dir2 test]
    set exe [makeFile {} temp.exe]
    set script [makeFile {
        set fp [open [file join $::installkit::root catalogs foo test] r]
        puts [string trim [read $fp]]
        close $fp
        set fp [open [file join $::installkit::root catalogs bar test] r]
        puts [string trim [read $fp]]
        close $fp
    } temp.tcl]
} -body {
    ::installkit::wrap -catalog $dir1 -o $exe -catalog $dir2 $script
    exec $exe
} -result {fooOK
barOK} -cleanup {
    file delete -force $dir1 $dir2 $exe $script
}

test ik-4.8.8 {::installkit::wrap, add files by absolute paths} -setup {
    set dir1 [makeDirectory foo]
    makeFile {fooOK} [file join $dir1 test]
    set file2 [makeFile {barOK} test]
    set exe [makeFile {} temp.exe]
    set script [makeFile {
        set fp [open [file join $::installkit::root {*}[file join [lrange [file split [pwd]] 1 end]] foo test] r]
        puts [string trim [read $fp]]
        close $fp
        set fp [open [file join $::installkit::root {*}[file join [lrange [file split [pwd]] 1 end]] test] r]
        puts [string trim [read $fp]]
        close $fp
    } temp.tcl]
} -body {
    set ::progress [list]
    set progress_cmd [list apply {{ file } {
        lappend ::progress "progress: $file"
    }}]
    ::installkit::wrap -command $progress_cmd -o $exe $script $dir1 $file2
    lappend ::progress [exec $exe]
    join $::progress \n
} -match glob -result {progress: */foo/test
progress: */test
fooOK
barOK} -cleanup {
    file delete -force $exe $script $dir1 $file2
}

test ik-4.8.9 {::installkit::wrap, add files by relative paths} -setup {
    set dir1 [makeDirectory foo]
    makeFile {fooOK} [file join $dir1 test]
    set file2 [makeFile {barOK} test]
    set exe [makeFile {} temp.exe]
    set script [makeFile {
        set fp [open [file join $::installkit::root foo test] r]
        puts [string trim [read $fp]]
        close $fp
        set fp [open [file join $::installkit::root test] r]
        puts [string trim [read $fp]]
        close $fp
    } temp.tcl]
} -body {
    set ::progress [list]
    set progress_cmd [list apply {{ file } {
        lappend ::progress "progress: $file"
    }}]
    set abs2rel [list apply {{ file } {
        return [file join {*}[lrange [file split $file] [llength [file split [pwd]]] end]]
    }}]
    ::installkit::wrap -command $progress_cmd -o $exe $script \
        [{*}$abs2rel $dir1] [{*}$abs2rel $file2]
    lappend ::progress [exec $exe]
    join $::progress \n
} -result {progress: foo/test
progress: test
fooOK
barOK} -cleanup {
    file delete -force $exe $script $dir1 $file2
}

test ik-4.8.10 {::installkit::wrap, preserve command line} -setup {
    set script [makeFile {
        puts -nonewline :[join $::argv :]:
    } temp.tcl]
    set exe "[file rootname $script]$exeext"
} -body {
    unset -nocomplain result
    ::installkit::wrap $script
    lappend result [exec $exe file.tcl 2 3 4]
    lappend result [exec $exe -file 2 3 4]
    lappend result [exec $exe -encoding utf-8 file 1 2]
    join $result \n
} -result {:file.tcl:2:3:4:
:-file:2:3:4:
:-encoding:utf-8:file:1:2:} -cleanup {
    file delete -force $exe $script
}

test ik-4.9.1 {::installkit::newThread} -constraints threaded -setup {
    set save [list ::argv $::argv ::argv0 $::argv0 ::tcl_interactive $::tcl_interactive]
    set ::argv [list "\{" "var" foo "\""]
    set ::argv0 bar
    set ::tcl_interactive false
} -body {
    set tid [::installkit::newThread thread::wait]
    ::thread::send $tid {
        list $::parentThread $::argv $::argv0 $::tcl_interactive [info script]
    } res
    lreplace $res 0 0 [expr { [lindex $res 0] eq [::thread::id]?"+":"-" }]
} -result [list + [list "\{" "var" foo "\""] bar false bar] -cleanup {
    foreach { k v } $save { set $k $v }
    ::thread::release $tid
}

test ik-4.9.2 {Test that cookfs package is present in new threads} -constraints threaded -setup {
} -body {
    set tid [::thread::create thread::wait]
    ::thread::send $tid { package present cookfs }
} -cleanup {
    ::thread::release $tid
    unset -nocomplain tid
} -result [package present cookfs]

# If VFS is mounted not as volume, then it is mounted relative to
# the current volume. On Windows it means that the root mount point will be
# unavailable when volume (drive) for pwd is changed. In order to avoid that,
# the root mount point should be registered as a volume.
#
# Also, when VFS is mounted as a volume, then 'file normalize' works
# as expected on Windows. For example, if VFS mount point is '/cvfs'
# and VFS is not a volume, then 'file normalize' adds current volume during
# normalization:
#
# (168) 1 % pwd
# D:/168
# (168) 2 % file normalize /cvfs
# D:/cvfs
# (168) 3 % file normalize /cvfs/some/file/here
# D:/cvfs/some/file/here
# (168) 4 %
#
# But it works as expected, when VFS is mounted as a volume:
#
# (168) 4 % file volumes
# /installkitvfs C:/ D:/ E:/ G:/ S:/ W:/
# (168) 5 % file normalize /installkitvfs
# /installkitvfs
# (168) 6 % file normalize /installkitvfs/some/file/here
# /installkitvfs/some/file/here
# (168) 7 %
#
# On the other hand, it is possible that the root file system is mounted
# several times. To avoid multiple mounts, here we check that there is exactly
# one root volume.
test ik-5.1 {Test that installkit root is a volume} -body {
    llength [lsearch -all -exact [file volumes] $::installkit::root]
} -result 1

test ik-5.2 {Check that there is only one installkit root volume for multiple interps} -setup {
    set interp1 [interp create]
    set interp2 [interp create]
} -body {
    llength [lsearch -all -exact [file volumes] $::installkit::root]
} -result 1 -cleanup {
    interp delete $interp1
    interp delete $interp2
    unset interp1 interp2
}

# cleanup
::tcltest::cleanupTests
return
